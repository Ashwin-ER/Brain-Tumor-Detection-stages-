# -*- coding: utf-8 -*-
"""Brain-Tumor-Detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MVMBk8My11mheVZYfoAVLZesEVefEhGo
"""

!pip install ultralytics

!pip install tensorflow

import cv2

from ultralytics import YOLO
import matplotlib.pyplot as plt

base = YOLO('yolov8n.pt')
res = base.train(data='brain-tumor.yaml', epochs=250, imgsz=1000, batch=16)

model = YOLO('/content/best.pt')

results = model.predict("/content/brain.jpg")

model.eval()

# prompt: plot the results with only positive label

results[0].plot(labels=False)

import cv2
cv2.imwrite('results.png', results[0].plot())

cv2.imwrite('results.jpg', results[0].plot(labels=False))

for result in results:
  boxes = result.boxes
  for box in boxes:
    class_id = box.cls.item()
    conf = box.conf.item()
    print(f"Class ID: {class_id}, Confidence: {conf:.2f}")

    image_width_pixels = 512
    image_height_pixels = 512
    pixel_spacing_mm = 0.5

    x_min, y_min, x_max, y_max = box.xyxy[0].tolist()

    tumor_width_pixels = x_max - x_min
    tumor_height_pixels = y_max - y_min

    tumor_width_mm = tumor_width_pixels * pixel_spacing_mm
    tumor_height_mm = tumor_height_pixels * pixel_spacing_mm

    tumor_width_cm = tumor_width_mm / 10
    tumor_height_cm = tumor_height_mm / 10

    print(f"Tumor width: {tumor_width_cm:.2f} cm, Tumor height: {tumor_height_cm:.2f} cm")

    if class_id == 0:
      print("Tumor type: Glioma")
    elif class_id == 1:
      print("Tumor type: Meningioma")
    elif class_id == 2:
      print("Tumor type: Pituitary tumor")
    elif class_id == 3:
      print("Tumor type: Acoustic neuroma")

model

model.info()

"""Accuracy Score by Inferencing the Model"""

import numpy as np
from ultralytics import YOLO
from sklearn.metrics import accuracy_score
from shapely.geometry import box

metrics = model.val(data='brain-tumor.yaml')

mAP_50_95 = metrics.box.map
mAP_50 = metrics.box.map50

print(f'mAP_50_95: {mAP_50_95:.2f}')
print(f'mAP_50: {mAP_50:.2f}')

precision = metrics.box.p
recall = metrics.box.r

print(precision)
print(recall)

# prompt: plot the curves

import matplotlib.pyplot as plt

# Extract data from metrics
epochs = list(range(1, len(curves_results.keys()) + 1))
train_loss = [res.results[epoch]['train/loss'] for epoch in epochs]
val_loss = [res.results[epoch]['val/loss'] for epoch in epochs]

# Plot the curves
plt.figure(figsize=(10, 6))
plt.plot(epochs, train_loss, label='Training Loss')
plt.plot(epochs, val_loss, label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.legend()
plt.grid(True)
plt.show()

metrics.curves_results

hub.login('b085f2e87bb707bb1c06ee55cce5fc74f8b0646803')
model = YOLO('https://hub.ultralytics.com/models/RdFDqB6Gr46bTwoaVmbn')

model.save('b-model.pt')

results = model.predict('/content/00056_239.jpg')

results[0].plot()

from ultralytics import hub,YOLO
import torch
print(not torch.cuda.is_available())



from ultralytics import YOLO
import cv2
import torchvision.transforms as transforms
from PIL import Image
import torch
import matplotlib.pyplot as plt

# Load a model
model = YOLO("b-model.pt")

results = model.predict("val_1 (15).jpg")

transform = transforms.Compose([
    transforms.Resize((640, 640)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

# Load and preprocess the image
image = Image.open('val_1 (15).jpg').convert('RGB') # Ensure the image is in RGB format
input_tensor = transform(image).unsqueeze(0)  # Add batch dimension

# Predict using the model
with torch.no_grad():
    outputs = model(input_tensor)

# Print the structure of outputs to understand its format
print(outputs[0])
# Depending on the structure, you might need to adjust how you extract boxes, scores, and labels

# Example: If 'boxes' are directly in outputs[0]
boxes = outputs[0].boxes.xyxy
scores = outputs[0].boxes.conf
labels = outputs[0].boxes.cls

# Visualize the bounding boxes on the image
def plot_boxes(image, boxes, labels, scores, threshold=0.5):
    plt.imshow(image)
    ax = plt.gca()
    for box, label, score in zip(boxes, labels, scores):
        if score > threshold:
            x1, y1, x2, y2 = box
            rect = plt.Rectangle((x1, y1), x2 - x1, y2 - y1, fill=False, color='red', linewidth=2)
            ax.add_patch(rect)
            ax.text(x1, y1, f'Label: {int(label)}, Score: {score:.2f}', bbox=dict(facecolor='yellow', alpha=0.5))
    plt.show()

# Plot the boxes on the original image
plot_boxes(image, boxes, labels, scores)

# Save the image with bounding boxes (adjust the method based on your model's output)
results[0].plot()

cv2.imwrite('results.png', results[0].plot())

from ultralytics import YOLO
import cv2
import   matplotlib.pyplot as plt
from torchvision import transforms
from PIL import Image

imgPath="/content/brain.jpg"
model = YOLO('/content/best.pt')

results = model.predict(imgPath, conf=0.25, iou=0.4)


transform = transforms.Compose([
    transforms.Resize((640, 640)),
    transforms.Grayscale(num_output_channels=3),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

image = Image.open(imgPath)
input_tensor = transform(image).unsqueeze(0)

# Extract results
for result in results:
    boxes = result.boxes
    if len(boxes) > 0:
        best_idx = boxes.conf.argmax()
        best_box = boxes[best_idx]
        x_min, y_min, x_max, y_max = best_box.xyxy[0].tolist()
        class_id = best_box.cls.item()
        conf = best_box.conf.item()

        # Extract tumor size (in pixels)
        tumor_width_pixels = x_max - x_min
        tumor_height_pixels = y_max - y_min

        # Assuming each pixel represents a specific physical size (e.g., 0.5mm per pixel)
        pixel_spacing_mm = 0.5
        tumor_width_mm = tumor_width_pixels * pixel_spacing_mm
        tumor_height_mm = tumor_height_pixels * pixel_spacing_mm

        tumor_width_cm = tumor_width_mm / 10
        tumor_height_cm = tumor_height_mm / 10

        # Determine tumor type and stage (custom logic can be applied here)
        tumor_type, tumor_stage = '', ''
        if class_id == 0:
            tumor_type = "Glioma"
        elif class_id == 1:
            tumor_type = "Meningioma"
        elif class_id == 2:
            tumor_type = "Pituitary tumor"
        elif class_id == 3:
            tumor_type = "Acoustic neuroma"

        # Print details
        print(f"Detected Tumor: {tumor_type}, Confidence: {conf:.2f}")
        print(f"Tumor size: {tumor_width_cm:.2f} cm x {tumor_height_cm:.2f} cm")
        print(f"Bounding box: [x_min: {x_min}, y_min: {y_min}, x_max: {x_max}, y_max: {y_max}]")

        # Load the image using OpenCV for drawing
        img = cv2.imread(imgPath)  # Replace with your image path
        cv2.rectangle(img, (int(x_min), int(y_min)), (int(x_max), int(y_max)), (255, 0, 0), 2)
        cv2.putText(img, f'{tumor_type}, {tumor_stage}', (int(x_min), int(y_min) - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 0, 0), 2)

        # Convert image from BGR to RGB for display
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.axis('off')  # Hide axes
        plt.show()
    else:
        print("No detections found.")